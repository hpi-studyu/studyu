#!/usr/bin/env bash

if [[ "$(head -c 1 <<< "$BASH_VERSION")" -lt 4 ]]; then
    echo "Bash version equal or larger than 4 is required to run this script."
    exit 1
fi

SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
PARENT_DIR=$(dirname "$SCRIPT_DIR")

# Color codes for better output
blue='\e[0;34m'
green='\e[0;32m'
yellow='\e[1;33m'
red='\e[0;31m'
bold='\e[1m'
reset='\e[0m'

# Configuration file path
# Check if the STUDYU_CONFIG_FILE environment variable is set
if [ -n "$STUDYU_CONFIG_FILE" ]; then
    CONFIG_FILE="$STUDYU_CONFIG_FILE"
else
    # Otherwise, fallback to the hardcoded path
    CONFIG_FILE="$SCRIPT_DIR/.studyu_config"
fi

# Dictionary to map components to Docker Compose files
declare -A compose_files=(
  ["proxy"]="nginx/docker-compose-proxy.yml"
  ["supabase-db"]="supabase/docker-compose-db.yml"
  ["supabase"]="supabase/docker-compose.yml"
  ["studyu-app"]="studyu/docker-compose-app.yml"
  ["studyu-designer"]="studyu/docker-compose-designer.yml"
)

declare -A component_descriptions=(
  ["proxy"]="Necessary to access the components"
  ["supabase-db"]="Database storing the Supabase data"
  ["supabase"]="Supabase services (need supabase-db)"
  ["studyu-app"]="StudyU App"
  ["studyu-designer"]="StudyU Designer"
)

declare -A default_component_values=(
  ["proxy"]="true"
  ["supabase-db"]="true"
  ["supabase"]="true"
  ["studyu-app"]="true"
  ["studyu-designer"]="true"
)

# Calculate the maximum length of the keys for formatting
max_length=0
for key in "${!component_descriptions[@]}"; do
  length=${#key}
  if ((length > max_length)); then
    max_length=$length
  fi
done

available_components="${bold}Available components:${reset}\n"
for key in "${!component_descriptions[@]}"; do
  value="${component_descriptions[$key]}"
  spaces=$(printf "%*s" $((max_length - ${#key})) "")
  formatted_component="  $key$spaces   $value\n"
  available_components+="$formatted_component"
done

function multiselect {
    # little helpers for terminal print control and key input
    ESC=$( printf "\033")
    cursor_blink_on()   { printf "%s" "${ESC}[?25h"; }
    cursor_blink_off()  { printf "%s" "${ESC}[?25l"; }
    cursor_to()         { printf "%s" "${ESC}[$1;${2:-1}H"; }
    # shellcheck disable=SC2059
    print_inactive()    { printf "$2   $1 "; }
    # shellcheck disable=SC2059
    print_active()      { printf "$2  ${ESC}[7m $1 ${ESC}[27m"; }
    # shellcheck disable=SC2034
    get_cursor_row()    { IFS=';' read -srdR -p $'\E[6n' ROW COL; echo "${ROW#*[}"; }

    local return_value=$1
    local -n options=$2
    local -n defaults=$3

    local selected=()
    for ((i=0; i<${#options[@]}; i++)); do
        if [[ ${defaults[i]} = "true" ]]; then
          selected+=("true")
           #selected+=("${options[i]}")
        else
            selected+=("false")
        fi
        printf "\n"
    done

    # determine current screen position for overwriting the options
    local lastrow
    lastrow=$(get_cursor_row)
    local startrow
    startrow=$((lastrow - ${#options[@]}))

    # ensure cursor and input echoing back on upon a ctrl+c during read -s
    trap "cursor_blink_on; stty echo; printf '\n'; exit" 2
    cursor_blink_off

    key_input() {
        local key
        IFS= read -rsn1 key 2>/dev/null >&2
        if [[ $key = ""      ]]; then echo enter; fi;
        if [[ $key = $'\x20' ]]; then echo space; fi;
        if [[ $key = "k" ]]; then echo up; fi;
        if [[ $key = "j" ]]; then echo down; fi;
        if [[ $key = $'\x1b' ]]; then
            read -rsn2 key
            if [[ $key = [A || $key = k ]]; then echo up;    fi;
            if [[ $key = [B || $key = j ]]; then echo down;  fi;
        fi
    }

    toggle_option() {
        local option=$1
        if [[ ${selected[option]} == true ]]; then
            selected[option]=false
        else
            selected[option]=true
        fi
    }

    print_options() {
        # print options by overwriting the last lines
        local idx=0
        for option in "${options[@]}"; do
            local prefix="[ ]"
            if [[ ${selected[idx]} == true ]]; then
              prefix="[\e[38;5;46m✔\e[0m]"
            fi

            cursor_to $((startrow + idx))
            if [ $idx -eq "$1" ]; then
                print_active "$option" "$prefix"
            else
                print_inactive "$option" "$prefix"
            fi
            ((idx++))
        done
    }

    local active=0
    while true; do
        print_options $active

        # user key control
        case $(key_input) in
            space)  toggle_option $active;;
            enter)  print_options -1; break;;
            up)     ((active--));
                    if [ $active -lt 0 ]; then active=$((${#options[@]} - 1)); fi;;
            down)   ((active++));
                    if [ "$active" -ge ${#options[@]} ]; then active=0; fi;;
        esac
    done

    # cursor position back to normal
    cursor_to "$lastrow"
    printf "\n"
    cursor_blink_on

    eval "$return_value"='("${selected[@]}")'
}

# Function to read configuration values from the file
read_config() {
  local failOnError="${1:-true}"

  if [[ ! -f "$CONFIG_FILE" ]]; then
    if [[ "$failOnError" == false ]]; then
      return 0
    else
      echo -e "${red}Error: Configuration file not found. Run '$0 config' to create one.${reset}"
      exit 1
    fi
  fi

  # Read the configuration file
  set -a
  #shellcheck source=.studyu_config
  source "$CONFIG_FILE"
  set +a

  # Check if the required variables are present
  if [[ "$failOnError" = true && -z "$STUDYU_DEFAULT_COMPONENTS" || -z "$STUDYU_PATH" || -z "$STUDYU_BASE_BRANCH" ]]; then
    echo -e "${red}Error: Configuration file $CONFIG_FILE is missing some entries.${reset}"
    echo "Run '$0 config' to set the required options."
    exit 1
  fi

  cd "$STUDYU_PATH/docker/" || exit 1
}


# Print CLI configuration file
print_config() {
  local failOnError="${1:-true}"
  read_config "$failOnError"

  # If the config file exists, display the current configuration
  if [ -f "$CONFIG_FILE" ]; then
    echo -e "${bold}Content of StudyU CLI configuration file $CONFIG_FILE:${reset}"
    local tmp_file
    tmp_file=$(mktemp)
    for var in "${!STUDYU@}"; do
      echo "$var:${!var}" >> "$tmp_file"
    done
    column -t -s ':' -c 2 "$tmp_file"
    rm "$tmp_file"
  fi
}


# Check if a component is running
component_is_running() {
  local component_name="$1"

  if ! docker info &>/dev/null; then
    echo "Docker daemon is not running."
    exit 1
  fi

  # Check if the container is running using Docker ps command
  local container_id
  container_id=$(docker ps -q -f name="$component_name")

  if [ -z "$container_id" ]; then
    # The container is not running
    return 1
  else
    # The container is running
    return 0
  fi
}


# Function to set configuration options
configure() {
  print_config false
  echo ""

  # Start the interactive configuration process
  echo -e "${bold}Configuring the StudyU CLI. Leave fields blank to use default settings.\n${reset}"

  # STUDYU_DEFAULT_COMPONENTS
  echo -e "${blue}Select the components that should be managed when none are explicitly defined.${reset}"
  echo -e "Multiselect help:"
  echo -e "j or ↓ => Go down";
  echo -e "k or ↑ => Go up";
  echo -e "␣ (Space) => Toggle selection";
  echo -e "↵ (Enter) => Confirm selection\n";
  local key_array=("${!component_descriptions[@]}")
  for key in "${!component_descriptions[@]}"; do
    multi_options+=("${bold}$key${reset} - ${component_descriptions[$key]}")
  done

  # shellcheck disable=SC2034
  local default_component_array=("${default_component_values[@]}")
  multiselect result multi_options default_component_array
  # shellcheck disable=SC2154
  for ((index=0; index<${#key_array[@]}; index++)); do
    key=${key_array[$index]}
    if [[ "${result[index]}" == true ]]; then
        default_components+=("$key")
    fi
  done
  echo -e "Selected components: ${default_components[*]}\n"

  # Validate selected components
  for component in "${default_components[@]}"; do
  if [[ ! ${compose_files[$component]+_} ]]; then
      echo -e "${red}Error: '$component' is not a valid component.${reset}"
      exit 1
  fi
  done

  # STUDYU_PATH
  read -rp "$(echo -e "Enter the path to the StudyU directory (default: $PARENT_DIR): ")" studyu_path
  studyu_path=${studyu_path:-$PARENT_DIR} # Set default if empty input

  # Validate the provided path existence
  if [ ! -d "$studyu_path" ]; then
    echo -e "${red}Error: The specified path does not exist.${reset}"
    exit 1
  fi

  # STUDYU_BASE_BRANCH
  read -rp "$(echo -e 'Enter the StudyU repository base branch for updating (default: main): ')" base_branch
  current_branch=$(git rev-parse --abbrev-ref HEAD)
  # Set base_branch to name of current branch, or "main" if current_branch is empty
  base_branch="${current_branch:-'main'}"

  # STUDYU_SECRETS_MANAGER
  read -rp "$(echo -e 'Enter an optional secrets manager to run with '\''docker compose'\'' (default: empty): ')" secrets_manager

  # Write the configuration to the file
  echo "STUDYU_DEFAULT_COMPONENTS=\"${default_components[*]}\"" > "$CONFIG_FILE"
  echo "STUDYU_PATH=\"$studyu_path\"" >> "$CONFIG_FILE"
  echo "STUDYU_BASE_BRANCH=\"$base_branch\"" >> "$CONFIG_FILE"

  # Set the secrets_manager in the configuration file only if it is not empty
  if [ -n "$secrets_manager" ]; then
    echo "STUDYU_SECRETS_MANAGER=\"$secrets_manager\"" >> "$CONFIG_FILE"
  fi

  echo -e "${green}Configuration successfully written to $CONFIG_FILE${reset}"
}


# Run docker compose command with optional secrets manager prefix
run_docker_compose() {
  local file="$1"
  local action="$2"
  # todo support this
  # local verbose="$3"

  # If STUDYU_SECRETS_MANAGER is not empty, use it as the prefix for the Docker Compose command
  local compose_command="docker compose -f $file $action"
  if [ -n "$STUDYU_SECRETS_MANAGER" ]; then
    compose_command="$STUDYU_SECRETS_MANAGER $compose_command"
  fi

  # Execute the Docker Compose command
  # if [ "$verbose" == "--verbose" ]; then
  $compose_command
  # else
  #  $compose_command >/dev/null 2>&1
  # fi

  # Check the exit status of the Docker Compose command and return an error if it failed
  local exit_status=$?
  if [ "$exit_status" -ne 0 ]; then
    echo -e "${red}Error: Docker Compose command failed with exit status $exit_status.${reset}"
    # echo -e "Run with --verbose for more information."
    exit "$exit_status"
  fi

}


# Run given docker compose commands such as start/restart/stop
manage_components() {
  local action=$1
  local components="${*:2}" # Get components, excluding the first argument (action)

  # If no components are specified, use the default components
  if [ -z "${components[*]}" ]; then
    components=("$STUDYU_DEFAULT_COMPONENTS")
  fi

  for component in ${components[*]}; do
    local compose_file="${compose_files[$component]}"
    if [ -z "$compose_file" ]; then
      echo -e "${red}Error: Invalid component '$component'${reset}"
      echo -e "$available_components"
      exit 1;
    fi

    if [[ "$action" == 'up'* && "$component" == 'supabase'* ]]; then
      local supabase_path
      supabase_path="$STUDYU_PATH/docker/supabase"
      if [ ! -f "$supabase_path/.env" ]; then
        echo -e "Could not find a Supabase .env file. Creating a default one at: $supabase_path${reset}"
        cp "$supabase_path/.env.example" "$supabase_path/.env"
        echo -e "${green}Supabase .env file created at: $supabase_path/.env${reset}"
        echo -e "Please modify the default secrets before starting the containers for the first time."
        exit 0
      fi
    fi

    if [[ "$action" == 'up'* && "$component" == 'proxy'* ]]; then
      local proxy_path
      proxy_path="$STUDYU_PATH/docker/nginx"
      if [ ! -f "$proxy_path/.env" ]; then
          cp "$proxy_path/.env.example" "$proxy_path/.env"
          echo -e "Proxy .env file created at: $$proxy_path/.env${reset}"
          echo -e "Modify it if you wish to deploy to remote."
      fi
    fi

    run_docker_compose "$compose_file" "$action"
  done
}

# Check if components are running healthy
status() {
  container_names=$(docker ps --filter "name=supabase" --filter "name=studyu" --format "{{.Names}}")

  if [ -z "$container_names" ]; then
    echo -e "No components are currently running."
    exit 2
  fi

  all_containers_healthy=true
  for name in $container_names; do
    health_status=$(docker inspect --format='{{.State.Running}}' "$name")

    if [ "$health_status" != "true" ]; then
      all_containers_healthy=false
      echo -e "${red}Error: $name is not running healthy. Check 'docker-compose ps' for troubleshooting.${reset}"
    fi
  done

  if [ "$all_containers_healthy" = true ]; then
    echo -e "${green}The following components are currently running healthy:${reset} ${container_names[*]}"
  else
    exit 1
  fi
}

# Start given components with docker compose
start() {
  # Check if studyu_network exists, otherwise create it
  docker network inspect studyu_network >/dev/null 2>&1 || \
      docker network create --driver bridge studyu_network
  manage_components 'up -d' "${@:2}"
}

restart() {
  manage_components "restart" "${@:2}"
}

stop() {
  manage_components "stop" "${@:2}"
}

down() {
  manage_components "down" "${@:2}"
}


# Update the StudyU repository
update() {
  read -rp "Do you want to create a backup of the StudyU database? (y/n): " BACKUP
  if [[ "$BACKUP" =~ ^[Yy]$ ]]; then
    backup
  fi

  # Check if any of the components are running.
  local components_running=()
  for component in "${!compose_files[@]}"; do
    if component_is_running "$component"; then
      components_running+=("$component")
    fi
  done

  # If any components are running, ask the user if they want to stop and remove them before updating.
  if [ ${#components_running[@]} -gt 0 ]; then
    read -rp "The following components '${components_running[*]}' are still running. Do you want to stop and remove them now before updating? (y/n): " STOP_CONTAINERS
    if [[ "$STOP_CONTAINERS" =~ ^[Yy]$ ]]; then
      manage_components "down" "${components_running[@]}"
    else
      echo -e "${red}Please stop the containers for components '${components_running[*]}' before updating.${reset}"
      exit 1
    fi
  fi

  # Check if there are modified files and ask the user if they should be stashed; else, stop.
  if ! git diff-index --quiet HEAD --; then
    read -rp "There are modified files. Do you want to stash them? (y/n): " STASH_FILES
    if [[ "$STASH_FILES" =~ ^[Yy]$ ]]; then
      git stash
    else
      echo "Please stash the changes before updating."
      exit 1
    fi
  fi

  # Check if we are in $STUDYU_BASE_BRANCH; if not, ask the user if the branch should be switched; else, stop.
  CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
  if [ "$CURRENT_BRANCH" != "$STUDYU_BASE_BRANCH" ]; then
    read -rp "You are on branch '$CURRENT_BRANCH'. Do you want to switch to '$STUDYU_BASE_BRANCH'? (y/n): " SWITCH_BRANCH
    if [[ "$SWITCH_BRANCH" =~ ^[Yy]$ ]]; then
      git checkout "$STUDYU_BASE_BRANCH"
    else
      echo "Please switch to the '$STUDYU_BASE_BRANCH' branch before updating."
      exit 1
    fi
  fi

  git pull

  # If we had stashed files before, then try to restore them now.
  if [[ "$STASH_FILES" =~ ^[Yy]$ ]]; then
    git stash pop
  fi

  read -rp "Update completed. Do you want to start the components again? (y/n): " START_CONTAINERS
  if [[ "$START_CONTAINERS" =~ ^[Yy]$ ]]; then
    start
  fi
  echo -e "${green}StudyU update finished.${reset}"
}


# Delete docker container, images, and volumes
delete() {
  local down_cmd="down "

  read -rp "Do you want to create a backup of the StudyU database? (y/n): " BACKUP
  if [[ "$BACKUP" =~ ^[Yy]$ ]]; then
    backup
  fi

  read -rp "Do you want to remove all containers and images used by StudyU services? This does not affect the StudyU data volumes. (y/n): " DELETE_CONTAINER_1
  if [[ "$DELETE_CONTAINER_1" =~ ^[Yy]$ ]]; then
    down_cmd+="--rmi all --remove-orphans"
  fi

  read -rp "Do you want to delete the StudyU Supabase volumes and the storage data? (y/n): " DELETE_VOLUMES_1
  if [[ "$DELETE_VOLUMES_1" =~ ^[Yy]$ ]]; then
    read -rp "Are you REALLY sure you want to delete all data? This includes all created studies, users, and their data. (y/n): " DELETE_VOLUMES_2
    if [[ "$DELETE_VOLUMES_2" =~ ^[Yy]$ ]]; then
      down_cmd+=" --volumes"
    fi
  fi

  if [ -n "$down_cmd" ]; then
    manage_components "$down_cmd"
    echo -e "${green}Success${reset}"
  else
    echo -e "No action taken."
  fi
}


# Function to backup StudyU components
backup() {
  # todo backup supabase storage
  CONTAINER_NAME="supabase-db"
  CURRENT_DATE=$(date +%Y-%m-%d)
  BACKUP_DIR="$STUDYU_PATH/backup"
  mkdir -p "$BACKUP_DIR"
  BACKUP_FILE="$BACKUP_DIR/pg_public_${CURRENT_DATE}.sql.gz"

  # Check if the supabase-db component is running
  if ! component_is_running "$CONTAINER_NAME"; then
    echo -e "${yellow}The supabase-db component is not running.${reset}"
    read -rp "Do you want to start supabase-db now? (y/n): " START_CONTAINER
    if [[ "$START_CONTAINER" =~ ^[Yy]$ ]]; then
      start start supabase-db
      until docker inspect --format "{{json .State.Health.Status }}" "$CONTAINER_NAME" | grep -q healthy; do
        echo "Waiting for supabase-db to be healthy..."
        sleep 3
      done
    else
      echo -e "${red}Please start the supabase-db component before backing up.${reset}"
      exit 1
    fi
  fi

  # Execute pg_dump command inside the Docker container
  docker exec $CONTAINER_NAME pg_dump -U postgres -t "public.*" | gzip > "$BACKUP_FILE"
  echo "StudyU database backup created at: '$BACKUP_FILE'"

  # Stop the container if it was not running before
  if [[ "$START_CONTAINER" =~ ^[Yy]$ ]]; then
    stop supabase-db
  fi

  echo -e "${green}StudyU database backup completed.${reset} It is advisable to schedule regular backups e.g. with 'crontab'."
}


# Function to display help
print_help() {
  echo "Welcome to the StudyU CLI"
  echo "Usage: $0 [options]"
  echo "Options:"
  echo "  config [--list]         Configure StudyU CLI settings"
  echo "  start <components>      Start components"
  echo "  restart <components>    Restart components"
  echo "  stop <components>       Stop components"
  echo "  down <components>       Stop and remove components"
  echo "  status                  Check if components are running healthy"
  echo "  update                  Perform StudyU update from specified branch"
  echo "  backup                  Dump StudyU data"
  echo "  delete                  Delete components and data (use with caution!)"
  echo "  help                    Display this help message"
  echo -e "$available_components"
}


# Main script
if [ $# -lt 1 ]; then
  echo -e "${red}Error: Missing argument. Use '$0 --help' to see available options.${reset}"
  exit 1
fi

case "$1" in
  config)
    case "$2" in
      --list | -l)
        print_config
        ;;
      *)
        configure
        ;;
    esac
    ;;
  status)
    read_config
    status "$@"
    ;;
  start)
    read_config
    start "$@"
    ;;
  restart)
    read_config
    restart "$@"
    ;;
  stop)
    read_config
    stop "$@"
    ;;
  down)
    read_config
    down "$@"
    ;;
  update)
    read_config
    update
    ;;
   backup)
    read_config
    backup
    ;;
  delete)
    read_config
    delete
    ;;
  --help | -h)
    print_help
    ;;
  *)
    echo -e "${red}Error: Invalid argument. Use '$0 --help' to see available options.${reset}"
    exit 1
    ;;
esac
